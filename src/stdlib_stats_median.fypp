#:include "common.fypp"
#:set RANKS = range(1, MAXRANK + 1)
#:set IR_KINDS_TYPES_OUTPUT = list(zip(REAL_KINDS, REAL_TYPES, REAL_KINDS)) + list(zip(INT_KINDS,INT_TYPES, ['dp']*len(INT_KINDS)))


submodule (stdlib_stats) stdlib_stats_median

  use, intrinsic:: ieee_arithmetic, only: ieee_value, ieee_quiet_nan
  use stdlib_error, only: error_stop
  use stdlib_optval, only: optval
  use stdlib_sorting, only: sort => sort
  implicit none

contains

  #:for k1, t1, o1 in IR_KINDS_TYPES_OUTPUT
    #:for rank in RANKS
      #:set RName = rname("median_all",rank, t1, k1, o1)
      pure module function ${RName}$ (x, mask) result(res)
        ${t1}$, intent(in) :: x${ranksuffix(rank)}$
        logical, intent(in), optional :: mask
        real(${o1}$) :: res

        integer(kind = int64) :: c, n
        ${t1}$, allocatable :: x_tmp(:)

        if (.not.optval(mask, .true.) .or. size(x) == 0) then
          res = ieee_value(1._${o1}$, ieee_quiet_nan)
          return
        end if

        n = size(x, kind=int64)
        c = floor( (n + 1) / 2._${o1}$, kind=int64 )

        x_tmp = reshape(x, [n])

        call sort(x_tmp)

        if (mod(n, 2_int64) == 0) then
          #:if t1[0] == 'r'
            res = sum(x_tmp(c:c+1)) / 2._${o1}$
          #:else
            res = sum( real(x_tmp(c:c+1), kind=${o1}$) ) / 2._${o1}$
          #:endif
        else
            res = x_tmp(c)
        end if

      end function ${RName}$
    #:endfor
  #:endfor

  #:for k1, t1, o1 in IR_KINDS_TYPES_OUTPUT
    #:for rank in RANKS
      #:set RName = rname("median",rank, t1, k1, o1)
      module function ${RName}$(x, dim, mask) result(res)
        ${t1}$, intent(in) :: x${ranksuffix(rank)}$
        integer, intent(in) :: dim
        logical, intent(in), optional :: mask
        real(${o1}$) :: res${reduced_shape('x', rank, 'dim')}$

        integer :: c, n
        #:if rank > 1
        #:for fj in range(1, rank+1)
        integer :: j${"_" * fj}$
        #:endfor
        #:endif
        ${t1}$, allocatable :: x_tmp(:)

        if (.not.optval(mask, .true.) .or. size(x) == 0) then
          res = ieee_value(1._${o1}$, ieee_quiet_nan)
          return
        end if

        n = size(x, dim)
        c = floor( (n + 1) / 2._${o1}$ )

        allocate(x_tmp(n))

        select case(dim)
          #:for fi in range(1, rank+1)
          case(${fi}$)
            #:for fj in range(1, fi)
              do j${"_" * fj}$ = 1, size(x, ${fj}$)
            #:endfor
              #:for fj in range(fi+1, rank+1)
                do j${"_" * fj}$ = 1, size(x, ${fj}$)
              #:endfor
                  x_tmp(:) = x${select_subvector(rank, fi)}$
                  call sort(x_tmp)

                  if (mod(n, 2) == 0) then
                      res${reduce_subvector(rank, fi)}$ = &
                      #:if t1[0] == 'r'
                          sum(x_tmp(c:c+1)) / 2._${o1}$
                      #:else
                          sum(real(x_tmp(c:c+1), kind=${o1}$) ) / 2._${o1}$
                      #:endif
                  else
                      res${reduce_subvector(rank, fi)}$ = x_tmp(c)
                  end if
            #:for fj in range(1, rank)
              end do
            #:endfor
          #:endfor
          case default
            call error_stop("ERROR (median): wrong dimension")
        end select

      end function ${RName}$
    #:endfor
  #:endfor


  #:for k1, t1, o1 in IR_KINDS_TYPES_OUTPUT
    #:for rank in RANKS
      #:set RName = rname('median_mask_all',rank, t1, k1, o1)
      module function ${RName}$(x, mask) result(res)
        ${t1}$, intent(in) :: x${ranksuffix(rank)}$
        logical, intent(in) :: mask${ranksuffix(rank)}$
        real(${o1}$) :: res

        integer(kind = int64) :: c, n
        ${t1}$, allocatable   :: x_tmp(:)

        if (any(shape(x) .ne. shape(mask))) then
            call error_stop("ERROR (median): shapes of x and mask are different")
        end if

        x_tmp = pack(x, mask)

        call sort(x_tmp)

        n = size(x_tmp, kind=int64 )
        c = floor( (n + 1) / 2._${o1}$, kind=int64 )

        if (n == 0) then
            res = ieee_value(1._${o1}$, ieee_quiet_nan)
        else if (mod(n, 2_int64) == 0) then
          #:if t1[0] == 'r'
            res = sum(x_tmp(c:c+1)) / 2._${o1}$
          #:else
            res = sum(real(x_tmp(c:c+1), kind=${o1}$)) / 2._${o1}$
          #:endif
        else if (mod(n, 2_int64) == 1) then
            res = x_tmp(c)
        end if

      end function ${RName}$
    #:endfor
  #:endfor

  #:for k1, t1, o1 in IR_KINDS_TYPES_OUTPUT
    #:for rank in RANKS
      #:set RName = rname('median_mask',rank, t1, k1, o1)
      module function ${RName}$(x, dim, mask) result(res)
        ${t1}$, intent(in) :: x${ranksuffix(rank)}$
        integer, intent(in) :: dim
        logical, intent(in) :: mask${ranksuffix(rank)}$
        real(${o1}$) :: res${reduced_shape('x', rank, 'dim')}$

        integer(kind = int64) :: c, n
        #:if rank > 1
        #:for fj in range(1, rank+1)
        integer :: j${"_" * fj}$
        #:endfor
        #:endif
        ${t1}$, allocatable :: x_tmp(:)

        if (any(shape(x) .ne. shape(mask))) then
            call error_stop("ERROR (median): shapes of x and mask are different")
        end if

        select case(dim)
          #:for fi in range(1, rank+1)
          case(${fi}$)
            #:for fj in range(1, fi)
              do j${"_" * fj}$ = 1, size(x, ${fj}$)
            #:endfor
              #:for fj in range(fi+1, rank+1)
                do j${"_" * fj}$ = 1, size(x, ${fj}$)
              #:endfor
                  x_tmp = pack(x${select_subvector(rank, fi)}$, &
                                mask${select_subvector(rank, fi)}$)
                  call sort(x_tmp)

                  n = size(x_tmp, kind=int64)
                  c = floor( (n + 1) / 2._${o1}$, kind=int64 )

                  if (n == 0) then
                      res${reduce_subvector(rank, fi)}$ = &
                          ieee_value(1._${o1}$, ieee_quiet_nan)
                  else if (mod(n, 2_int64) == 0) then
                      res${reduce_subvector(rank, fi)}$ = &
                      #:if t1[0] == 'r'
                          sum(x_tmp(c:c+1)) / 2._${o1}$
                      #:else
                          sum(real(x_tmp(c:c+1), kind=${o1}$)) / 2._${o1}$
                      #:endif
                  else if (mod(n, 2_int64) == 1) then
                      res${reduce_subvector(rank, fi)}$ = x_tmp(c)
                  end if

                  deallocate(x_tmp)
            #:for fj in range(1, rank)
              end do
            #:endfor
          #:endfor
          case default
            call error_stop("ERROR (median): wrong dimension")
        end select

      end function ${RName}$
    #:endfor
  #:endfor

end submodule
