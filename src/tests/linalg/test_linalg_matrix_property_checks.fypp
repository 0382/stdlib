#:include "common.fypp"
#:set RCI_KINDS_TYPES = REAL_KINDS_TYPES + CMPLX_KINDS_TYPES + INT_KINDS_TYPES

module test_linalg_matrix_property_checks
    use testdrive, only : new_unittest, unittest_type, error_type, check, skip_test
    use stdlib_kinds, only: sp, dp, xdp, qp, int8, int16, int32, int64
    use stdlib_linalg, only: is_square ,is_diagonal, is_symmetric, &
        is_skew_symmetric, is_hermitian, is_triangular, is_hessenberg

    implicit none

    real(sp), parameter :: sptol = 1000 * epsilon(1._sp)
    real(dp), parameter :: dptol = 1000 * epsilon(1._dp)
#:if WITH_QP
    real(qp), parameter :: qptol = 1000 * epsilon(1._qp)
#:endif

  #! create new list that contains test subroutine suffix (rsp, cdp, int64, etc.)
  #! alongside kind and type
  #:set RCI_KINDS_TYPES_SUFFIXES = []
  #:for k1, t1 in RCI_KINDS_TYPES
    #:if t1[0] == 'i'
        #:set SUFFIX_START = ''
    #:else
        #:set SUFFIX_START = t1[0]
    #:endif
    $:RCI_KINDS_TYPES_SUFFIXES.append((k1,t1,SUFFIX_START+k1))
  #:endfor


contains


    !> Collect all exported unit tests
    subroutine collect_linalg_matrix_property_checks(testsuite)
        !> Collection of tests
        type(unittest_type), allocatable, intent(out) :: testsuite(:)


      #:set IMPLEMENTED_TESTS = ['is_square','is_diagonal']

      #:set NUM_TESTS = int(len(IMPLEMENTED_TESTS)*len(RCI_KINDS_TYPES_SUFFIXES))

        #! set testsuite dynamically
        testsuite = [ &
      #:set TESTS_WRITTEN = 0
      #:for cur_test in IMPLEMENTED_TESTS
        #:for k1, t1, s1 in RCI_KINDS_TYPES_SUFFIXES
          #! note that one has to use set directives to increment variable
          #:set TESTS_WRITTEN = TESTS_WRITTEN + 1
          #! last test in list should not have comma
          #:if TESTS_WRITTEN < NUM_TESTS
            new_unittest("${cur_test}$_${s1}$", test_is_square_rsp), &
          #:else
            new_unittest("${cur_test}$_${s1}$", test_is_square_rsp) &
          #:endif
        #:endfor
      #:endfor
            ]

    end subroutine collect_linalg_matrix_property_checks

    !is_square
  #:for k1, t1, s1 in RCI_KINDS_TYPES_SUFFIXES
    subroutine test_is_square_${s1}$(error)
        !> Error handling
        type(error_type), allocatable, intent(out) :: error

      #!populate variables dependent on type/kind
      #:if s1[0] == 'r'
        ${t1}$ :: A_true(2,2), A_false(2,3)
        A_true = reshape([1.,2.,3.,4.],[2,2])
        A_false = reshape([1.,2.,3.,4.,5.,6.],[2,3])
      #:elif s1[0] == 'c'
        ${t1}$ :: A_true(2,2), A_false(2,3)
        A_true = reshape([cmplx(1.,0.),cmplx(2.,1.),cmplx(3.,0.),cmplx(4.,1.)],[2,2])
        A_false = reshape([cmplx(1.,0.),cmplx(2.,1.),cmplx(3.,0.), &
            cmplx(4.,1.),cmplx(5.,0.),cmplx(6.,1.)],[2,3])
      #:elif s1[0] == 'i'
        ${t1}$ :: A_true(2,2), A_false(2,3)
        A_true = reshape([1,2,3,4],[2,2])
        A_false = reshape([1,2,3,4,5,6],[2,3])
      #:endif

      #! all error check calls are type/kind independent
        call check(error, is_square(A_true), &
            "is_square(A_true) failed.")
        if (allocated(error)) return
        call check(error, (.not. is_square(A_false)), &
            "(.not. is_square(A_false)) failed.")
        if (allocated(error)) return
    end subroutine test_is_square_${s1}$
  #:endfor


    !is_diagonal
  #:for k1, t1, s1 in RCI_KINDS_TYPES_SUFFIXES
    subroutine test_is_diagonal_${s1}$(error)
        !> Error handling
        type(error_type), allocatable, intent(out) :: error

      #!populate variables dependent on type/kind
      #:if s1[0] == 'r'
        ${t1}$ :: A_true_s(2,2), A_false_s(2,2) !square matrices
        ${t1}$ :: A_true_sf(2,3), A_false_sf(2,3) !short and fat matrices
        ${t1}$ :: A_true_ts(3,2), A_false_ts(3,2) !tall and skinny matrices
        A_true_s = reshape([1.,0.,0.,4.],[2,2])
        A_false_s = reshape([1.,0.,3.,4.],[2,2])
        A_true_sf = reshape([1.,0.,0.,4.,0.,0.],[2,3])
        A_false_sf = reshape([1.,0.,3.,4.,0.,0.],[2,3])
        A_true_ts = reshape([1.,0.,0.,0.,5.,0.],[3,2])
        A_false_ts = reshape([1.,0.,0.,0.,5.,6.],[3,2])
      #:elif s1[0] == 'c'
        ${t1}$ :: A_true_s(2,2), A_false_s(2,2) !square matrices
        ${t1}$ :: A_true_sf(2,3), A_false_sf(2,3) !short and fat matrices
        ${t1}$ :: A_true_ts(3,2), A_false_ts(3,2) !tall and skinny matrices
        A_true_s = reshape([cmplx(1.,1.),cmplx(0.,0.), &
            cmplx(0.,0.),cmplx(4.,1.)],[2,2]) 
        A_false_s = reshape([cmplx(1.,1.),cmplx(0.,0.), &
            cmplx(3.,1.),cmplx(4.,1.)],[2,2])
        A_true_sf = reshape([cmplx(1.,1.),cmplx(0.,0.), &
            cmplx(0.,0.),cmplx(4.,1.), &
            cmplx(0.,0.),cmplx(0.,0.)],[2,3])
        A_false_sf = reshape([cmplx(1.,1.),cmplx(0.,0.), &
            cmplx(3.,1.),cmplx(4.,1.), &
            cmplx(0.,0.),cmplx(0.,0.)],[2,3])
        A_true_ts = reshape([cmplx(1.,1.),cmplx(0.,0.),cmplx(0.,0.), &
            cmplx(0.,0.),cmplx(5.,1.),cmplx(0.,0.)],[3,2])
        A_false_ts = reshape([cmplx(1.,1.),cmplx(0.,0.),cmplx(0.,0.), &
            cmplx(0.,0.),cmplx(5.,1.),cmplx(6.,1.)],[3,2])
      #:elif s1[0] == 'i'
        ${t1}$ :: A_true_s(2,2), A_false_s(2,2) !square matrices
        ${t1}$ :: A_true_sf(2,3), A_false_sf(2,3) !short and fat matrices
        ${t1}$ :: A_true_ts(3,2), A_false_ts(3,2) !tall and skinny matrices
        A_true_s = reshape([1,0,0,4],[2,2])
        A_false_s = reshape([1,0,3,4],[2,2])
        A_true_sf = reshape([1,0,0,4,0,0],[2,3])
        A_false_sf = reshape([1,0,3,4,0,0],[2,3])
        A_true_ts = reshape([1,0,0,0,5,0],[3,2])
        A_false_ts = reshape([1,0,0,0,5,6],[3,2])
      #:endif

      #! all error check calls are type/kind independent
        call check(error, is_diagonal(A_true_s), &
            "is_diagonal(A_true_s) failed.")
        if (allocated(error)) return
        call check(error, (.not. is_diagonal(A_false_s)), &
            "(.not. is_diagonal(A_false_s)) failed.")
        if (allocated(error)) return
        call check(error, is_diagonal(A_true_sf), &
            "is_diagonal(A_true_sf) failed.")
        if (allocated(error)) return
        call check(error, (.not. is_diagonal(A_false_sf)), &
            "(.not. is_diagonal(A_false_sf)) failed.")
        if (allocated(error)) return
        call check(error, is_diagonal(A_true_ts), &
            "is_diagonal(A_true_ts) failed.")
        if (allocated(error)) return
        call check(error, (.not. is_diagonal(A_false_ts)), &
            "(.not. is_diagonal(A_false_ts)) failed.")
        if (allocated(error)) return
    end subroutine test_is_diagonal_${s1}$
  #:endfor


    !is_symmetric
  #:for k1, t1, s1 in RCI_KINDS_TYPES_SUFFIXES
    subroutine test_is_symmetric_${s1}$(error)
        !> Error handling
        type(error_type), allocatable, intent(out) :: error

      #!populate variables dependent on type/kind
      #:if s1[0] == 'r'
        ${t1}$ :: A_true(2,2), A_false_1(2,2), A_false_2(3,2)
        A_true = reshape([1.,2.,2.,4.],[2,2])
        A_false_1 = reshape([1.,2.,3.,4.],[2,2])
        A_false_2 = reshape([1.,2.,3.,2.,5.,6.],[3,2]) !nonsquare matrix
      #:elif s1[0] == 'c'
        ${t1}$ :: A_true(2,2), A_false_1(2,2), A_false_2(3,2)
        A_true = reshape([cmplx(1.,1.),cmplx(2.,1.), &
            cmplx(2.,1.),cmplx(4.,1.)],[2,2])
        A_false_1 = reshape([cmplx(1.,1.),cmplx(2.,1.), &
            cmplx(3.,1.),cmplx(4.,1.)],[2,2])
        A_false_2 = reshape([cmplx(1.,1.),cmplx(2.,1.),cmplx(3.,1.), &
            cmplx(2.,1.),cmplx(5.,1.),cmplx(6.,2.)],[3,2]) !nonsquare matrix
      #:elif s1[0] == 'i'
        ${t1}$ :: A_true(2,2), A_false_1(2,2), A_false_2(3,2)
        A_true = reshape([1,2,2,4],[2,2])
        A_false_1 = reshape([1,2,3,4],[2,2])
        A_false_2 = reshape([1,2,3,2,5,6],[3,2]) !nonsquare matrix
      #:endif

      #! all error check calls are type/kind independent
        call check(error, is_symmetric(A_true), &
            "is_symmetric(A_true) failed.")
        if (allocated(error)) return
        call check(error, (.not. is_symmetric(A_false_1)), &
            "(.not. is_symmetric(A_false_1)) failed.")
        if (allocated(error)) return
        call check(error, (.not. is_symmetric(A_false_2)), &
            "(.not. is_symmetric(A_false_2)) failed.")
        if (allocated(error)) return
    end subroutine test_is_symmetric_${s1}$
  #:endfor





!    !TEST TEMPLATE
!    !is_diagonal
!  #:for k1, t1, s1 in RCI_KINDS_TYPES_SUFFIXES
!    subroutine test_is_diagonal_${s1}$(error)
!        !> Error handling
!        type(error_type), allocatable, intent(out) :: error
!
!      #!populate variables dependent on type/kind
!      #:if s1[0] == 'r'
!      #:elif s1[0] == 'c'
!      #:elif s1[0] == 'i'
!      #:endif
!
!      #! all error check calls are type/kind independent
!    end subroutine test_is_diagonal_${s1}$
!  #:endfor

end module

program tester
    use, intrinsic :: iso_fortran_env, only : error_unit
    use testdrive, only : run_testsuite, new_testsuite, testsuite_type
    use test_linalg_matrix_property_checks, only : collect_linalg_matrix_property_checks
    implicit none
    integer :: stat, is
    type(testsuite_type), allocatable :: testsuites(:)
    character(len=*), parameter :: fmt = '("#", *(1x, a))'

    stat = 0

    testsuites = [ &
        new_testsuite("linalg_matrix_property_checks", collect_linalg_matrix_property_checks) &
        ]

    do is = 1, size(testsuites)
        write(error_unit, fmt) "Testing:", testsuites(is)%name
        call run_testsuite(testsuites(is)%collect, error_unit, stat)
    end do

    if (stat > 0) then
        write(error_unit, '(i0, 1x, a)') stat, "test(s) failed!"
        error stop
    end if
end program
